#version 450

// These should match the constants defined in image_blur.c
#define TILE_DIM 256
#define BATCH_0 4
#define BATCH_1 4

layout(set = 0, binding = 0) uniform sampler samp;
layout(set = 0, binding = 1) uniform Params {
  uint uFilterDim;
  uint uBlockDim;
};
layout(set = 1, binding = 1) uniform texture2D inputTex;
layout(set = 1, binding = 2, rgba8) uniform writeonly image2D outputTex;
layout(set = 1, binding = 3) uniform Uniforms {
  uint uFlip;
};

// This shader blurs the input texture in one diection, depending on whether
// |uFlip| is 0 or 1.
// It does so by running (TILE_DIM / BATCH_0) threads per workgroup to load TILE_DIM
// texels into BATCH_1 rows of shared memory. Each thread loads a
// (BATCH_0 x BATCH_1) block of texels to take advantage of the texture sampling
// hardware.
// Then, each thread computes the blur result by averaging the adjacent texel values
// in shared memory.
// Because we're operating on a subset of the texture, we cannot compute all of the
// results since not all of the neighbors are available in shared memory.
// Specifically, with TILE_DIM x TILE_DIM tiles, we can only compute and write out
// square blocks of size TILE_DIM - (filterSize - 1). We compute the number of blocks
// needed and dispatch that amount.

shared vec3[TILE_DIM] tile[BATCH_1];

layout(local_size_x = (TILE_DIM / BATCH_0), local_size_y = 1, local_size_z = 1) in;
void main() {
  int filterOffset = int(uFilterDim - 1) / 2;
  ivec2 dims = textureSize(sampler2D(inputTex, samp), 0);

  ivec2 baseIndex = ivec2(
    gl_WorkGroupID.xy * uvec2(uBlockDim, BATCH_1) +
    gl_LocalInvocationID.xy * uvec2(BATCH_0, 1)
  ) - ivec2(filterOffset, 0);

  for (uint r = 0; r < BATCH_1; ++r) {
    for (uint c = 0; c < BATCH_0; ++c) {
      ivec2 loadIndex = baseIndex + ivec2(c, r);
      if (uFlip != 0) {
        loadIndex = loadIndex.yx;
      }

      tile[r][BATCH_0 * gl_LocalInvocationID.x + c] =
        texture(
          sampler2D(inputTex, samp),
          (vec2(loadIndex) + vec2(0.25)) / vec2(dims)).rgb;
    }
  }

  barrier();

  for (uint r = 0; r < BATCH_1; ++r) {
    for (uint c = 0; c < BATCH_0; ++c) {
      ivec2 writeIndex = baseIndex + ivec2(c, r);
      if (uFlip != 0) {
        writeIndex = writeIndex.yx;
      }

      uint center = BATCH_0 * gl_LocalInvocationID.x + c;
      if (center >= filterOffset &&
          center < TILE_DIM - filterOffset &&
          all(lessThan(writeIndex, dims))) {
        vec3 acc = vec3(0.0);
        for (uint f = 0; f < uFilterDim; ++f) {
          uint i = center + f - filterOffset;
          acc += (1.0 / float(uFilterDim)) * tile[r][i];
        }
        imageStore(outputTex, writeIndex, vec4(acc, 1.0));
      }
    }
  }
}
